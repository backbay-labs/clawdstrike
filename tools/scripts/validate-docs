#!/usr/bin/env python3
from __future__ import annotations

import argparse
import pathlib
import re
import subprocess
import sys
import tempfile
from dataclasses import dataclass
from typing import Iterable, Iterator


@dataclass(frozen=True)
class CodeBlock:
    path: pathlib.Path
    start_line: int
    language: str
    body: str


FENCE_RE = re.compile(r"^```(?P<lang>\\S+)?\\s*$")


def iter_markdown_files(root: pathlib.Path) -> Iterable[pathlib.Path]:
    return sorted(p for p in root.rglob("*.md") if p.is_file())


def extract_fenced_blocks(path: pathlib.Path) -> Iterator[CodeBlock]:
    text = path.read_text(encoding="utf-8")
    in_block = False
    lang = ""
    start_line = 0
    buf: list[str] = []

    for lineno, line in enumerate(text.splitlines(keepends=True), start=1):
        m = FENCE_RE.match(line)
        if m:
            if not in_block:
                in_block = True
                lang = (m.group("lang") or "").strip().lower()
                start_line = lineno + 1
                buf = []
            else:
                yield CodeBlock(path=path, start_line=start_line, language=lang, body="".join(buf))
                in_block = False
                lang = ""
                start_line = 0
                buf = []
            continue

        if in_block:
            buf.append(line)

    if in_block:
        raise ValueError(f"Unclosed fenced code block in {path}:{start_line}")


def iter_shell_blocks(blocks: Iterable[CodeBlock]) -> Iterator[CodeBlock]:
    for b in blocks:
        if b.language in {"bash", "sh", "shell"}:
            yield b


def bash_syntax_check(block: CodeBlock) -> list[str]:
    with tempfile.NamedTemporaryFile(
        mode="w", encoding="utf-8", suffix=".sh", delete=True
    ) as f:
        f.write(block.body)
        f.flush()
        proc = subprocess.run(
            ["bash", "-n", f.name],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
        if proc.returncode == 0:
            return []
        msg = proc.stderr.strip() or proc.stdout.strip() or "bash -n failed"
        return [f"{block.path}:{block.start_line}: {msg}"]


def main(argv: list[str]) -> int:
    parser = argparse.ArgumentParser(description="Validate docs code blocks (no execution).")
    parser.add_argument(
        "--docs-root",
        default="docs/src",
        help="Root directory to scan (default: docs/src)",
    )
    args = parser.parse_args(argv)

    docs_root = pathlib.Path(args.docs_root)
    if not docs_root.exists():
        print(f"docs root not found: {docs_root}", file=sys.stderr)
        return 2

    md_files = list(iter_markdown_files(docs_root))
    errors: list[str] = []

    for path in md_files:
        try:
            blocks = list(extract_fenced_blocks(path))
        except ValueError as e:
            errors.append(str(e))
            continue

        for block in iter_shell_blocks(blocks):
            errors.extend(bash_syntax_check(block))

    if errors:
        for e in errors:
            print(e, file=sys.stderr)
        return 1

    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))

