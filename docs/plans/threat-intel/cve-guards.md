# CVE-Aware Guards Design

## Document Information

| Field | Value |
|-------|-------|
| Version | 1.0.0-draft |
| Status | Proposal |
| Component | CveGuard |
| Last Updated | 2026-02-02 |

---

## 1. Problem Statement

### 1.1 The Risk

AI agents frequently modify package manifests, install dependencies, and write code that imports libraries. Without CVE awareness:

1. **Vulnerable Dependencies**: Agents may add packages with known critical vulnerabilities
2. **Downgrade Attacks**: Agents may downgrade packages to vulnerable versions
3. **Transitive Vulnerabilities**: Indirect dependencies may introduce vulnerabilities
4. **Zero-Day Exposure Window**: Time between CVE publication and remediation

### 1.2 Examples

```json
// Agent writes this to package.json
{
  "dependencies": {
    "lodash": "4.17.20",     // CVE-2021-23337 (Prototype Pollution)
    "axios": "0.21.0",        // CVE-2021-3749 (ReDoS)
    "minimist": "1.2.5"       // CVE-2021-44906 (Prototype Pollution)
  }
}
```

```toml
# Agent writes this to Cargo.toml
[dependencies]
regex = "1.4.6"              # CVE-2022-24713 (ReDoS)
hyper = "0.14.11"            # Multiple security advisories
```

### 1.3 Goals

- Block writes that introduce packages with known critical/high CVEs
- Warn on medium severity CVEs
- Provide actionable remediation guidance
- Support multiple ecosystems (npm, PyPI, crates.io, Maven, Go)
- Maintain low latency with local caching

---

## 2. Architecture

### 2.1 System Overview

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           CveGuard                                       │
└───────────────────────────────────┬─────────────────────────────────────┘
                                    │
                                    v
┌─────────────────────────────────────────────────────────────────────────┐
│                     Manifest Parser                                      │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │
│  │ package.json│  │ Cargo.toml  │  │requirements │  │   go.mod    │   │
│  │   Parser    │  │   Parser    │  │.txt Parser  │  │   Parser    │   │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘   │
└───────────────────────────────────┬─────────────────────────────────────┘
                                    │
                                    v
┌─────────────────────────────────────────────────────────────────────────┐
│                     Dependency Extractor                                 │
│  - Extract package name + version constraint                            │
│  - Resolve version ranges to specific versions                          │
│  - Detect version changes (adds, updates, removes)                      │
└───────────────────────────────────┬─────────────────────────────────────┘
                                    │
                                    v
┌─────────────────────────────────────────────────────────────────────────┐
│                     CVE Database                                         │
│                                                                         │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐        │
│  │   NVD (NIST)    │  │   OSV.dev       │  │ GitHub Advisory │        │
│  │   Database      │  │   Database      │  │   Database      │        │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘        │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    Local Cache (SQLite)                          │   │
│  │  - Package -> CVE mappings                                       │   │
│  │  - Version range affected                                        │   │
│  │  - Severity, CVSS scores                                         │   │
│  │  - Fixed versions                                                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└───────────────────────────────────┬─────────────────────────────────────┘
                                    │
                                    v
┌─────────────────────────────────────────────────────────────────────────┐
│                     Vulnerability Assessor                               │
│  - Match package@version against CVE database                           │
│  - Calculate aggregate risk score                                       │
│  - Generate remediation recommendations                                 │
└───────────────────────────────────┬─────────────────────────────────────┘
                                    │
                                    v
┌─────────────────────────────────────────────────────────────────────────┐
│                         Guard Decision                                   │
│  - Block / Warn / Allow based on policy                                 │
│  - Return detailed vulnerability report                                 │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Data Flow

```
                    Manifest Write Event
                           │
                           v
        ┌──────────────────┴──────────────────┐
        │         Diff Detection               │
        │  - Compare old vs new manifest      │
        │  - Extract added/changed packages   │
        └──────────────────┬──────────────────┘
                           │
              ┌────────────┴────────────┐
              │                         │
              v                         v
     ┌────────────────┐        ┌────────────────┐
     │ New Dependency │        │ Version Change │
     │    Check       │        │    Check       │
     └───────┬────────┘        └───────┬────────┘
             │                         │
             └────────────┬────────────┘
                          │
                          v
              ┌───────────────────────┐
              │   CVE Database Query  │
              │  - Check all affected │
              │  - Include transitive │
              └───────────┬───────────┘
                          │
                          v
              ┌───────────────────────┐
              │  Vulnerability Report │
              │  - CVE IDs            │
              │  - Severity           │
              │  - Fixed versions     │
              │  - Exploit available? │
              └───────────┬───────────┘
                          │
                          v
              ┌───────────────────────┐
              │   Policy Evaluation   │
              │  - block_severity     │
              │  - warn_severity      │
              │  - exceptions         │
              └───────────┬───────────┘
                          │
                          v
                   Guard Decision
```

---

## 3. API Design

### 3.1 Rust Interface

```rust
//! CVE-Aware Guards for Clawdstrike
//!
//! Prevents introduction of vulnerable dependencies.

use std::collections::HashMap;
use std::path::Path;
use std::sync::Arc;

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use semver::{Version, VersionReq};
use serde::{Deserialize, Serialize};
use tokio::sync::RwLock;

use crate::guards::{Guard, GuardAction, GuardContext, GuardResult, Severity};

/// CVSS severity levels
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum CveSeverity {
    None,
    Low,
    Medium,
    High,
    Critical,
}

impl CveSeverity {
    /// Convert from CVSS v3 score
    pub fn from_cvss_score(score: f32) -> Self {
        match score {
            s if s == 0.0 => CveSeverity::None,
            s if s < 4.0 => CveSeverity::Low,
            s if s < 7.0 => CveSeverity::Medium,
            s if s < 9.0 => CveSeverity::High,
            _ => CveSeverity::Critical,
        }
    }
}

/// Package ecosystem
#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Ecosystem {
    Npm,
    PyPi,
    Crates,
    Go,
    Maven,
    NuGet,
    RubyGems,
    Packagist,
}

impl Ecosystem {
    /// Detect ecosystem from file path
    pub fn from_path(path: &Path) -> Option<Self> {
        let filename = path.file_name()?.to_str()?;
        match filename {
            "package.json" | "package-lock.json" | "npm-shrinkwrap.json" => Some(Ecosystem::Npm),
            "Cargo.toml" | "Cargo.lock" => Some(Ecosystem::Crates),
            "requirements.txt" | "Pipfile" | "pyproject.toml" | "poetry.lock" => Some(Ecosystem::PyPi),
            "go.mod" | "go.sum" => Some(Ecosystem::Go),
            "pom.xml" | "build.gradle" | "build.gradle.kts" => Some(Ecosystem::Maven),
            "Gemfile" | "Gemfile.lock" => Some(Ecosystem::RubyGems),
            "composer.json" | "composer.lock" => Some(Ecosystem::Packagist),
            _ => None,
        }
    }
}

/// A package dependency
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct PackageDependency {
    /// Package name
    pub name: String,
    /// Version or version constraint
    pub version: String,
    /// Resolved version (if constraint was resolved)
    pub resolved_version: Option<String>,
    /// Package ecosystem
    pub ecosystem: Ecosystem,
    /// Whether this is a dev dependency
    pub dev: bool,
    /// Whether this is a transitive dependency
    pub transitive: bool,
}

/// A CVE record
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct CveRecord {
    /// CVE identifier (e.g., "CVE-2021-44228")
    pub cve_id: String,
    /// Aliases (e.g., GHSA IDs)
    pub aliases: Vec<String>,
    /// Severity
    pub severity: CveSeverity,
    /// CVSS v3 score
    pub cvss_score: Option<f32>,
    /// CVSS v3 vector
    pub cvss_vector: Option<String>,
    /// Summary description
    pub summary: String,
    /// Detailed description
    pub description: Option<String>,
    /// Affected package
    pub package: String,
    /// Affected ecosystem
    pub ecosystem: Ecosystem,
    /// Affected version range
    pub affected_versions: String,
    /// First patched/fixed version
    pub fixed_version: Option<String>,
    /// Publication date
    pub published: DateTime<Utc>,
    /// Last modified date
    pub modified: DateTime<Utc>,
    /// References/URLs
    pub references: Vec<String>,
    /// Whether exploit is publicly available
    pub exploit_available: bool,
    /// CWE IDs
    pub cwes: Vec<String>,
}

impl CveRecord {
    /// Check if a version is affected
    pub fn affects_version(&self, version: &str) -> bool {
        // Parse affected version range and check
        // This is ecosystem-specific version matching
        if let Ok(ver) = Version::parse(version) {
            // Try to parse affected_versions as semver range
            if let Ok(req) = VersionReq::parse(&self.affected_versions) {
                return req.matches(&ver);
            }
        }
        // Fallback to string matching for complex ranges
        true // Conservative: assume affected if can't parse
    }

    /// Check if a version is fixed
    pub fn is_fixed_in(&self, version: &str) -> bool {
        if let Some(ref fixed) = self.fixed_version {
            if let (Ok(ver), Ok(fixed_ver)) = (Version::parse(version), Version::parse(fixed)) {
                return ver >= fixed_ver;
            }
        }
        false
    }
}

/// Vulnerability finding
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct VulnerabilityFinding {
    /// The CVE record
    pub cve: CveRecord,
    /// The dependency that introduces this vulnerability
    pub dependency: PackageDependency,
    /// Recommended fix version
    pub fix_version: Option<String>,
    /// Whether this is a direct or transitive dependency
    pub is_transitive: bool,
}

/// Vulnerability report for a manifest
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct VulnerabilityReport {
    /// All findings
    pub findings: Vec<VulnerabilityFinding>,
    /// Counts by severity
    pub by_severity: HashMap<CveSeverity, usize>,
    /// Total number of vulnerabilities
    pub total_count: usize,
    /// Highest severity found
    pub max_severity: CveSeverity,
    /// Number of fixable vulnerabilities
    pub fixable_count: usize,
    /// Scan timestamp
    pub scanned_at: DateTime<Utc>,
    /// Data source versions used
    pub data_sources: Vec<String>,
}

impl VulnerabilityReport {
    pub fn empty() -> Self {
        Self {
            findings: vec![],
            by_severity: HashMap::new(),
            total_count: 0,
            max_severity: CveSeverity::None,
            fixable_count: 0,
            scanned_at: Utc::now(),
            data_sources: vec![],
        }
    }

    /// Generate human-readable summary
    pub fn summary(&self) -> String {
        if self.findings.is_empty() {
            return "No known vulnerabilities found".to_string();
        }

        let mut parts = vec![];
        parts.push(format!("{} vulnerabilities found", self.total_count));

        if let Some(&critical) = self.by_severity.get(&CveSeverity::Critical) {
            if critical > 0 {
                parts.push(format!("{} critical", critical));
            }
        }
        if let Some(&high) = self.by_severity.get(&CveSeverity::High) {
            if high > 0 {
                parts.push(format!("{} high", high));
            }
        }

        if self.fixable_count > 0 {
            parts.push(format!("{} fixable", self.fixable_count));
        }

        parts.join(", ")
    }

    /// Generate remediation recommendations
    pub fn recommendations(&self) -> Vec<String> {
        let mut recs = vec![];

        for finding in &self.findings {
            if let Some(ref fix) = finding.fix_version {
                recs.push(format!(
                    "Update {} from {} to {} to fix {}",
                    finding.dependency.name,
                    finding.dependency.version,
                    fix,
                    finding.cve.cve_id
                ));
            }
        }

        // Deduplicate and limit
        recs.sort();
        recs.dedup();
        recs.truncate(10);
        recs
    }
}

/// CVE database trait
#[async_trait]
pub trait CveDatabase: Send + Sync {
    /// Query vulnerabilities for a package
    async fn query(&self, package: &str, version: &str, ecosystem: &Ecosystem) -> Vec<CveRecord>;

    /// Batch query for multiple packages
    async fn batch_query(&self, packages: &[PackageDependency]) -> Vec<CveRecord>;

    /// Update the database from sources
    async fn update(&self) -> Result<CveUpdateResult, CveDatabaseError>;

    /// Get database statistics
    async fn stats(&self) -> CveDatabaseStats;
}

/// CVE database update result
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct CveUpdateResult {
    pub success: bool,
    pub records_added: u64,
    pub records_updated: u64,
    pub duration_ms: u64,
    pub sources_updated: Vec<String>,
    pub error: Option<String>,
}

/// CVE database statistics
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct CveDatabaseStats {
    pub total_records: u64,
    pub records_by_ecosystem: HashMap<String, u64>,
    pub last_update: Option<DateTime<Utc>>,
    pub database_size_bytes: u64,
}

/// CVE database errors
#[derive(Debug, thiserror::Error)]
pub enum CveDatabaseError {
    #[error("Fetch failed: {0}")]
    FetchError(String),
    #[error("Parse error: {0}")]
    ParseError(String),
    #[error("Database error: {0}")]
    DatabaseError(String),
}

/// Data source for CVE information
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum CveDataSource {
    /// NIST NVD
    Nvd {
        api_key_env: Option<String>,
    },
    /// OSV.dev
    Osv,
    /// GitHub Advisory Database
    GitHubAdvisory {
        token_env: Option<String>,
    },
    /// Custom URL
    Custom {
        url: String,
        format: String,
    },
}

/// CVE guard configuration
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct CveConfig {
    /// Whether the guard is enabled
    #[serde(default = "default_true")]
    pub enabled: bool,

    /// Severity levels that cause blocking
    #[serde(default = "default_block_severity")]
    pub block_severity: Vec<CveSeverity>,

    /// Severity levels that cause warnings
    #[serde(default = "default_warn_severity")]
    pub warn_severity: Vec<CveSeverity>,

    /// Data sources to use
    #[serde(default = "default_data_sources")]
    pub data_sources: Vec<CveDataSource>,

    /// Check transitive dependencies
    #[serde(default = "default_true")]
    pub check_transitive: bool,

    /// Maximum depth for transitive dependency checking
    #[serde(default = "default_max_depth")]
    pub max_transitive_depth: u32,

    /// Path to local database cache
    #[serde(default = "default_db_path")]
    pub database_path: String,

    /// Update interval for CVE database (hours)
    #[serde(default = "default_update_interval")]
    pub update_interval_hours: u32,

    /// Package exceptions (always allow)
    #[serde(default)]
    pub exceptions: Vec<PackageException>,

    /// CVE exceptions (always allow)
    #[serde(default)]
    pub cve_exceptions: Vec<String>,

    /// Fail closed if database unavailable
    #[serde(default)]
    pub fail_closed: bool,
}

fn default_true() -> bool { true }
fn default_block_severity() -> Vec<CveSeverity> { vec![CveSeverity::Critical, CveSeverity::High] }
fn default_warn_severity() -> Vec<CveSeverity> { vec![CveSeverity::Medium] }
fn default_data_sources() -> Vec<CveDataSource> {
    vec![CveDataSource::Osv, CveDataSource::GitHubAdvisory { token_env: None }]
}
fn default_max_depth() -> u32 { 2 }
fn default_db_path() -> String { ".clawdstrike/cve.db".to_string() }
fn default_update_interval() -> u32 { 24 }

impl Default for CveConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            block_severity: default_block_severity(),
            warn_severity: default_warn_severity(),
            data_sources: default_data_sources(),
            check_transitive: true,
            max_transitive_depth: 2,
            database_path: default_db_path(),
            update_interval_hours: 24,
            exceptions: vec![],
            cve_exceptions: vec![],
            fail_closed: false,
        }
    }
}

/// Package exception configuration
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct PackageException {
    /// Package name pattern (supports glob)
    pub package: String,
    /// Ecosystem (optional, matches all if not specified)
    pub ecosystem: Option<Ecosystem>,
    /// Reason for exception
    pub reason: String,
    /// Expiration date (optional)
    pub expires: Option<DateTime<Utc>>,
}

/// Manifest parser trait
pub trait ManifestParser: Send + Sync {
    /// Parse a manifest file and extract dependencies
    fn parse(&self, content: &str) -> Result<Vec<PackageDependency>, ManifestParseError>;

    /// Get the ecosystem this parser handles
    fn ecosystem(&self) -> Ecosystem;
}

/// Manifest parse error
#[derive(Debug, thiserror::Error)]
pub enum ManifestParseError {
    #[error("Invalid format: {0}")]
    InvalidFormat(String),
    #[error("Missing required field: {0}")]
    MissingField(String),
}

/// Package.json parser
pub struct PackageJsonParser;

impl ManifestParser for PackageJsonParser {
    fn parse(&self, content: &str) -> Result<Vec<PackageDependency>, ManifestParseError> {
        let json: serde_json::Value = serde_json::from_str(content)
            .map_err(|e| ManifestParseError::InvalidFormat(e.to_string()))?;

        let mut deps = Vec::new();

        // Parse dependencies
        if let Some(dependencies) = json.get("dependencies").and_then(|d| d.as_object()) {
            for (name, version) in dependencies {
                if let Some(ver) = version.as_str() {
                    deps.push(PackageDependency {
                        name: name.clone(),
                        version: ver.to_string(),
                        resolved_version: None,
                        ecosystem: Ecosystem::Npm,
                        dev: false,
                        transitive: false,
                    });
                }
            }
        }

        // Parse devDependencies
        if let Some(dev_deps) = json.get("devDependencies").and_then(|d| d.as_object()) {
            for (name, version) in dev_deps {
                if let Some(ver) = version.as_str() {
                    deps.push(PackageDependency {
                        name: name.clone(),
                        version: ver.to_string(),
                        resolved_version: None,
                        ecosystem: Ecosystem::Npm,
                        dev: true,
                        transitive: false,
                    });
                }
            }
        }

        Ok(deps)
    }

    fn ecosystem(&self) -> Ecosystem {
        Ecosystem::Npm
    }
}

/// Cargo.toml parser
pub struct CargoTomlParser;

impl ManifestParser for CargoTomlParser {
    fn parse(&self, content: &str) -> Result<Vec<PackageDependency>, ManifestParseError> {
        let toml: toml::Value = toml::from_str(content)
            .map_err(|e| ManifestParseError::InvalidFormat(e.to_string()))?;

        let mut deps = Vec::new();

        // Parse [dependencies]
        if let Some(dependencies) = toml.get("dependencies").and_then(|d| d.as_table()) {
            for (name, value) in dependencies {
                let version = match value {
                    toml::Value::String(v) => v.clone(),
                    toml::Value::Table(t) => {
                        t.get("version")
                            .and_then(|v| v.as_str())
                            .unwrap_or("*")
                            .to_string()
                    }
                    _ => continue,
                };

                deps.push(PackageDependency {
                    name: name.clone(),
                    version,
                    resolved_version: None,
                    ecosystem: Ecosystem::Crates,
                    dev: false,
                    transitive: false,
                });
            }
        }

        // Parse [dev-dependencies]
        if let Some(dev_deps) = toml.get("dev-dependencies").and_then(|d| d.as_table()) {
            for (name, value) in dev_deps {
                let version = match value {
                    toml::Value::String(v) => v.clone(),
                    toml::Value::Table(t) => {
                        t.get("version")
                            .and_then(|v| v.as_str())
                            .unwrap_or("*")
                            .to_string()
                    }
                    _ => continue,
                };

                deps.push(PackageDependency {
                    name: name.clone(),
                    version,
                    resolved_version: None,
                    ecosystem: Ecosystem::Crates,
                    dev: true,
                    transitive: false,
                });
            }
        }

        Ok(deps)
    }

    fn ecosystem(&self) -> Ecosystem {
        Ecosystem::Crates
    }
}

/// Requirements.txt parser
pub struct RequirementsTxtParser;

impl ManifestParser for RequirementsTxtParser {
    fn parse(&self, content: &str) -> Result<Vec<PackageDependency>, ManifestParseError> {
        let mut deps = Vec::new();

        for line in content.lines() {
            let line = line.trim();

            // Skip comments and empty lines
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            // Skip options
            if line.starts_with('-') {
                continue;
            }

            // Parse package==version or package>=version etc.
            let (name, version) = if let Some(idx) = line.find("==") {
                (line[..idx].to_string(), line[idx + 2..].to_string())
            } else if let Some(idx) = line.find(">=") {
                (line[..idx].to_string(), format!(">={}", &line[idx + 2..]))
            } else if let Some(idx) = line.find("<=") {
                (line[..idx].to_string(), format!("<={}", &line[idx + 2..]))
            } else {
                (line.to_string(), "*".to_string())
            };

            deps.push(PackageDependency {
                name: name.trim().to_string(),
                version: version.trim().to_string(),
                resolved_version: None,
                ecosystem: Ecosystem::PyPi,
                dev: false,
                transitive: false,
            });
        }

        Ok(deps)
    }

    fn ecosystem(&self) -> Ecosystem {
        Ecosystem::PyPi
    }
}

/// Default CVE database implementation using OSV.dev
pub struct OsvDatabase {
    cache: Arc<RwLock<sled::Db>>,
    last_update: Arc<RwLock<Option<DateTime<Utc>>>>,
}

impl OsvDatabase {
    pub async fn new(db_path: &str) -> Result<Self, CveDatabaseError> {
        let cache = sled::open(db_path)
            .map_err(|e| CveDatabaseError::DatabaseError(e.to_string()))?;

        Ok(Self {
            cache: Arc::new(RwLock::new(cache)),
            last_update: Arc::new(RwLock::new(None)),
        })
    }
}

#[async_trait]
impl CveDatabase for OsvDatabase {
    async fn query(&self, package: &str, version: &str, ecosystem: &Ecosystem) -> Vec<CveRecord> {
        let osv_ecosystem = match ecosystem {
            Ecosystem::Npm => "npm",
            Ecosystem::PyPi => "PyPI",
            Ecosystem::Crates => "crates.io",
            Ecosystem::Go => "Go",
            Ecosystem::Maven => "Maven",
            _ => return vec![],
        };

        // Query OSV.dev API
        // API docs: https://osv.dev/docs/
        // Note: OSV severity uses database_specific.severity or CVSS in severity array
        let client = reqwest::Client::new();
        let response = client
            .post("https://api.osv.dev/v1/query")
            .json(&serde_json::json!({
                "package": {
                    "name": package,
                    "ecosystem": osv_ecosystem
                },
                "version": version
            }))
            .send()
            .await;

        let response = match response {
            Ok(r) => r,
            Err(_) => return vec![],
        };

        let osv_response: serde_json::Value = match response.json().await {
            Ok(v) => v,
            Err(_) => return vec![],
        };

        // Convert OSV response to CveRecords
        let mut records = Vec::new();
        if let Some(vulns) = osv_response.get("vulns").and_then(|v| v.as_array()) {
            for vuln in vulns {
                let cve_id = vuln.get("id")
                    .and_then(|v| v.as_str())
                    .unwrap_or("")
                    .to_string();

                let severity = vuln.get("severity")
                    .and_then(|s| s.as_array())
                    .and_then(|arr| arr.first())
                    .and_then(|s| s.get("score"))
                    .and_then(|s| s.as_str())
                    .and_then(|s| s.parse::<f32>().ok())
                    .map(CveSeverity::from_cvss_score)
                    .unwrap_or(CveSeverity::Medium);

                let summary = vuln.get("summary")
                    .and_then(|v| v.as_str())
                    .unwrap_or("")
                    .to_string();

                let fixed_version = vuln.get("affected")
                    .and_then(|a| a.as_array())
                    .and_then(|arr| arr.first())
                    .and_then(|a| a.get("ranges"))
                    .and_then(|r| r.as_array())
                    .and_then(|arr| arr.first())
                    .and_then(|r| r.get("events"))
                    .and_then(|e| e.as_array())
                    .and_then(|arr| arr.iter().find(|e| e.get("fixed").is_some()))
                    .and_then(|e| e.get("fixed"))
                    .and_then(|f| f.as_str())
                    .map(String::from);

                records.push(CveRecord {
                    cve_id,
                    aliases: vec![],
                    severity,
                    cvss_score: None,
                    cvss_vector: None,
                    summary,
                    description: None,
                    package: package.to_string(),
                    ecosystem: ecosystem.clone(),
                    affected_versions: "*".to_string(),
                    fixed_version,
                    published: Utc::now(),
                    modified: Utc::now(),
                    references: vec![],
                    exploit_available: false,
                    cwes: vec![],
                });
            }
        }

        records
    }

    async fn batch_query(&self, packages: &[PackageDependency]) -> Vec<CveRecord> {
        let mut all_records = Vec::new();

        for pkg in packages {
            let records = self.query(&pkg.name, &pkg.version, &pkg.ecosystem).await;
            all_records.extend(records);
        }

        all_records
    }

    async fn update(&self) -> Result<CveUpdateResult, CveDatabaseError> {
        // OSV.dev doesn't require bulk updates - queries are live
        let mut last_update = self.last_update.write().await;
        *last_update = Some(Utc::now());

        Ok(CveUpdateResult {
            success: true,
            records_added: 0,
            records_updated: 0,
            duration_ms: 0,
            sources_updated: vec!["osv.dev".to_string()],
            error: None,
        })
    }

    async fn stats(&self) -> CveDatabaseStats {
        let last_update = self.last_update.read().await;

        CveDatabaseStats {
            total_records: 0, // Live queries, no local count
            records_by_ecosystem: HashMap::new(),
            last_update: *last_update,
            database_size_bytes: 0,
        }
    }
}

/// CVE guard implementation
pub struct CveGuard {
    config: CveConfig,
    database: Arc<dyn CveDatabase>,
    parsers: HashMap<Ecosystem, Arc<dyn ManifestParser>>,
}

impl CveGuard {
    pub async fn new(config: CveConfig) -> Result<Self, CveDatabaseError> {
        let database: Arc<dyn CveDatabase> = Arc::new(
            OsvDatabase::new(&config.database_path).await?
        );

        let mut parsers: HashMap<Ecosystem, Arc<dyn ManifestParser>> = HashMap::new();
        parsers.insert(Ecosystem::Npm, Arc::new(PackageJsonParser));
        parsers.insert(Ecosystem::Crates, Arc::new(CargoTomlParser));
        parsers.insert(Ecosystem::PyPi, Arc::new(RequirementsTxtParser));

        Ok(Self {
            config,
            database,
            parsers,
        })
    }

    /// Scan a manifest for vulnerabilities
    pub async fn scan_manifest(
        &self,
        content: &str,
        ecosystem: &Ecosystem,
    ) -> Result<VulnerabilityReport, ManifestParseError> {
        let parser = self.parsers.get(ecosystem)
            .ok_or_else(|| ManifestParseError::InvalidFormat(
                format!("No parser for ecosystem: {:?}", ecosystem)
            ))?;

        let dependencies = parser.parse(content)?;
        let cve_records = self.database.batch_query(&dependencies).await;

        let mut findings = Vec::new();
        let mut by_severity: HashMap<CveSeverity, usize> = HashMap::new();
        let mut max_severity = CveSeverity::None;
        let mut fixable_count = 0;

        for cve in cve_records {
            // Check exceptions
            if self.config.cve_exceptions.contains(&cve.cve_id) {
                continue;
            }

            let dep = dependencies.iter()
                .find(|d| d.name == cve.package)
                .cloned()
                .unwrap_or_else(|| PackageDependency {
                    name: cve.package.clone(),
                    version: "unknown".to_string(),
                    resolved_version: None,
                    ecosystem: ecosystem.clone(),
                    dev: false,
                    transitive: false,
                });

            // Check package exceptions
            let is_excepted = self.config.exceptions.iter().any(|exc| {
                if let Some(ref eco) = exc.ecosystem {
                    if eco != ecosystem {
                        return false;
                    }
                }
                if let Some(ref expires) = exc.expires {
                    if Utc::now() > *expires {
                        return false;
                    }
                }
                glob::Pattern::new(&exc.package)
                    .map(|p| p.matches(&dep.name))
                    .unwrap_or(false)
            });

            if is_excepted {
                continue;
            }

            if cve.fixed_version.is_some() {
                fixable_count += 1;
            }

            if cve.severity > max_severity {
                max_severity = cve.severity;
            }

            *by_severity.entry(cve.severity).or_insert(0) += 1;

            findings.push(VulnerabilityFinding {
                cve: cve.clone(),
                dependency: dep,
                fix_version: cve.fixed_version.clone(),
                is_transitive: false,
            });
        }

        let total_count = findings.len();

        Ok(VulnerabilityReport {
            findings,
            by_severity,
            total_count,
            max_severity,
            fixable_count,
            scanned_at: Utc::now(),
            data_sources: vec!["osv.dev".to_string()],
        })
    }

    /// Check if severity should block
    fn should_block(&self, severity: CveSeverity) -> bool {
        self.config.block_severity.contains(&severity)
    }

    /// Check if severity should warn
    fn should_warn(&self, severity: CveSeverity) -> bool {
        self.config.warn_severity.contains(&severity)
    }
}

#[async_trait]
impl Guard for CveGuard {
    fn name(&self) -> &str {
        "cve"
    }

    fn handles(&self, action: &GuardAction<'_>) -> bool {
        match action {
            GuardAction::FileWrite(path, _) | GuardAction::Patch(path, _) => {
                Ecosystem::from_path(std::path::Path::new(path)).is_some()
            }
            _ => false,
        }
    }

    async fn check(&self, action: &GuardAction<'_>, _context: &GuardContext) -> GuardResult {
        if !self.config.enabled {
            return GuardResult::allow(self.name());
        }

        let (path, content) = match action {
            GuardAction::FileWrite(path, content) => {
                (*path, String::from_utf8_lossy(content).to_string())
            }
            GuardAction::Patch(path, diff) => (*path, diff.to_string()),
            _ => return GuardResult::allow(self.name()),
        };

        let ecosystem = match Ecosystem::from_path(std::path::Path::new(path)) {
            Some(e) => e,
            None => return GuardResult::allow(self.name()),
        };

        let report = match self.scan_manifest(&content, &ecosystem).await {
            Ok(r) => r,
            Err(e) => {
                if self.config.fail_closed {
                    return GuardResult::block(
                        self.name(),
                        Severity::Error,
                        format!("CVE scan failed: {}", e),
                    );
                }
                return GuardResult::warn(
                    self.name(),
                    format!("CVE scan failed: {}", e),
                );
            }
        };

        if report.findings.is_empty() {
            return GuardResult::allow(self.name())
                .with_details(serde_json::json!({
                    "message": "No vulnerabilities found",
                    "scanned_at": report.scanned_at,
                }));
        }

        // Check for blocking vulnerabilities
        if self.should_block(report.max_severity) {
            return GuardResult::block(
                self.name(),
                Severity::Critical,
                format!(
                    "Blocked: {}. Recommendations: {}",
                    report.summary(),
                    report.recommendations().join("; ")
                ),
            )
            .with_details(serde_json::to_value(&report).unwrap_or_default());
        }

        // Check for warning vulnerabilities
        if self.should_warn(report.max_severity) {
            return GuardResult::warn(
                self.name(),
                format!(
                    "Warning: {}. Recommendations: {}",
                    report.summary(),
                    report.recommendations().join("; ")
                ),
            )
            .with_details(serde_json::to_value(&report).unwrap_or_default());
        }

        GuardResult::allow(self.name())
            .with_details(serde_json::to_value(&report).unwrap_or_default())
    }
}
```

### 3.2 TypeScript Interface

```typescript
/**
 * @clawdstrike/openclaw - CVE Guard
 */

import type { Guard, GuardResult, PolicyEvent, Policy } from '../types.js';

/** CVSS severity levels */
export type CveSeverity = 'none' | 'low' | 'medium' | 'high' | 'critical';

/** Package ecosystem */
export type Ecosystem = 'npm' | 'pypi' | 'crates' | 'go' | 'maven' | 'nuget' | 'rubygems';

/** Package dependency */
export interface PackageDependency {
  name: string;
  version: string;
  resolvedVersion?: string;
  ecosystem: Ecosystem;
  dev: boolean;
  transitive: boolean;
}

/** CVE record */
export interface CveRecord {
  cveId: string;
  aliases: string[];
  severity: CveSeverity;
  cvssScore?: number;
  summary: string;
  package: string;
  ecosystem: Ecosystem;
  affectedVersions: string;
  fixedVersion?: string;
  published: string;
  exploitAvailable: boolean;
}

/** Vulnerability finding */
export interface VulnerabilityFinding {
  cve: CveRecord;
  dependency: PackageDependency;
  fixVersion?: string;
  isTransitive: boolean;
}

/** Vulnerability report */
export interface VulnerabilityReport {
  findings: VulnerabilityFinding[];
  bySeverity: Record<CveSeverity, number>;
  totalCount: number;
  maxSeverity: CveSeverity;
  fixableCount: number;
  scannedAt: string;
  dataSources: string[];
}

/** CVE guard configuration */
export interface CveConfig {
  enabled?: boolean;
  blockSeverity?: CveSeverity[];
  warnSeverity?: CveSeverity[];
  dataSources?: CveDataSource[];
  checkTransitive?: boolean;
  maxTransitiveDepth?: number;
  databasePath?: string;
  updateIntervalHours?: number;
  exceptions?: PackageException[];
  cveExceptions?: string[];
  failClosed?: boolean;
}

/** CVE data source */
export type CveDataSource =
  | { type: 'nvd'; apiKeyEnv?: string }
  | { type: 'osv' }
  | { type: 'github_advisory'; tokenEnv?: string };

/** Package exception */
export interface PackageException {
  package: string;
  ecosystem?: Ecosystem;
  reason: string;
  expires?: string;
}

/**
 * CVE Guard implementation
 */
export class CveGuard implements Guard {
  private config: Required<CveConfig>;

  constructor(config: CveConfig = {}) {
    this.config = {
      enabled: config.enabled ?? true,
      blockSeverity: config.blockSeverity ?? ['critical', 'high'],
      warnSeverity: config.warnSeverity ?? ['medium'],
      dataSources: config.dataSources ?? [{ type: 'osv' }],
      checkTransitive: config.checkTransitive ?? true,
      maxTransitiveDepth: config.maxTransitiveDepth ?? 2,
      databasePath: config.databasePath ?? '.clawdstrike/cve.db',
      updateIntervalHours: config.updateIntervalHours ?? 24,
      exceptions: config.exceptions ?? [],
      cveExceptions: config.cveExceptions ?? [],
      failClosed: config.failClosed ?? false,
    };
  }

  name(): string {
    return 'cve';
  }

  handles(): Array<import('../types.js').EventType> {
    return ['file_write', 'patch_apply'];
  }

  isEnabled(): boolean {
    return this.config.enabled;
  }

  async check(event: PolicyEvent, _policy: Policy): Promise<GuardResult> {
    if (!this.config.enabled) {
      return { status: 'allow', guard: this.name() };
    }

    // Only handle file writes to manifest files
    if (event.data.type !== 'file' && event.data.type !== 'patch') {
      return { status: 'allow', guard: this.name() };
    }

    const path = event.data.type === 'file' ? event.data.path : event.data.filePath;
    const ecosystem = this.detectEcosystem(path);

    if (!ecosystem) {
      return { status: 'allow', guard: this.name() };
    }

    try {
      const report = await this.scanManifest(path, ecosystem);

      if (report.totalCount === 0) {
        return { status: 'allow', guard: this.name() };
      }

      if (this.shouldBlock(report.maxSeverity)) {
        return {
          status: 'deny',
          reason: `${report.totalCount} vulnerabilities found (${report.maxSeverity} severity)`,
          severity: 'critical',
          guard: this.name(),
        };
      }

      if (this.shouldWarn(report.maxSeverity)) {
        return {
          status: 'warn',
          reason: `${report.totalCount} vulnerabilities found (${report.maxSeverity} severity)`,
          guard: this.name(),
        };
      }

      return { status: 'allow', guard: this.name() };
    } catch (error) {
      if (this.config.failClosed) {
        return {
          status: 'deny',
          reason: `CVE scan failed: ${error}`,
          severity: 'high',
          guard: this.name(),
        };
      }
      return {
        status: 'warn',
        reason: `CVE scan failed: ${error}`,
        guard: this.name(),
      };
    }
  }

  private detectEcosystem(path: string): Ecosystem | null {
    const filename = path.split('/').pop() ?? '';
    const mapping: Record<string, Ecosystem> = {
      'package.json': 'npm',
      'package-lock.json': 'npm',
      'Cargo.toml': 'crates',
      'Cargo.lock': 'crates',
      'requirements.txt': 'pypi',
      'pyproject.toml': 'pypi',
      'go.mod': 'go',
      'go.sum': 'go',
    };
    return mapping[filename] ?? null;
  }

  private shouldBlock(severity: CveSeverity): boolean {
    return this.config.blockSeverity.includes(severity);
  }

  private shouldWarn(severity: CveSeverity): boolean {
    return this.config.warnSeverity.includes(severity);
  }

  private async scanManifest(path: string, ecosystem: Ecosystem): Promise<VulnerabilityReport> {
    // Query OSV.dev API
    // Implementation would parse the manifest and query for each dependency
    return {
      findings: [],
      bySeverity: {} as Record<CveSeverity, number>,
      totalCount: 0,
      maxSeverity: 'none',
      fixableCount: 0,
      scannedAt: new Date().toISOString(),
      dataSources: ['osv.dev'],
    };
  }
}
```

---

## 4. Data Models

### 4.1 Policy Configuration

```yaml
version: "1.0.0"
guards:
  cve:
    enabled: true
    block_severity:
      - critical
      - high
    warn_severity:
      - medium
    data_sources:
      - type: osv
      - type: github_advisory
        token_env: GITHUB_TOKEN
    check_transitive: true
    max_transitive_depth: 2
    update_interval_hours: 12
    exceptions:
      - package: "lodash"
        reason: "Vulnerability not exploitable in our usage"
        expires: "2026-06-01T00:00:00Z"
    cve_exceptions:
      - CVE-2021-23337  # False positive for our use case
    fail_closed: false
```

---

## 5. Performance Considerations

### 5.1 Caching Strategy

```rust
// Local CVE cache for offline/fast lookups
struct CveCache {
    // Package -> CVEs mapping
    by_package: HashMap<(String, Ecosystem), Vec<CveRecord>>,
    // CVE ID -> Record
    by_id: HashMap<String, CveRecord>,
    // Last update timestamp
    last_update: DateTime<Utc>,
}
```

### 5.2 Latency Targets

| Operation | Target | Strategy |
|-----------|--------|----------|
| Manifest parse | < 10ms | Streaming parsers |
| Local CVE lookup | < 5ms | In-memory cache |
| Remote CVE query | < 500ms | OSV.dev API |
| Full scan | < 1s | Parallel queries |

---

## 6. Security Considerations

- **Fail-Safe Defaults**: Block on critical/high by default
- **Database Integrity**: Verify signatures on CVE database updates
- **No Code Execution**: Manifest parsing must not execute arbitrary code
- **Rate Limiting**: Respect API rate limits for external sources

---

## 7. Implementation Phases

### Phase 1: Core (Week 1-2)
- [ ] Manifest parsers (package.json, Cargo.toml, requirements.txt)
- [ ] OSV.dev integration
- [ ] Basic guard implementation

### Phase 2: Enhanced Detection (Week 2-3)
- [ ] GitHub Advisory integration
- [ ] Transitive dependency analysis
- [ ] Local caching

### Phase 3: Production Ready (Week 3-4)
- [ ] NVD integration
- [ ] Exception management
- [ ] Performance optimization

---

## 8. Related Documents

- [overview.md](./overview.md) - Threat Intelligence Overview
- [blocklists.md](./blocklists.md) - Blocklist Architecture
- [yara-integration.md](./yara-integration.md) - YARA Integration
