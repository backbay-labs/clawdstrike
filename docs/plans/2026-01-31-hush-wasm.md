# hush-wasm Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create WebAssembly bindings for hush-core to enable browser-based and Node.js verification of receipts, signatures, and Merkle proofs.

**Architecture:** The hush-wasm crate wraps hush-core primitives with wasm-bindgen exports. Functions accept/return JavaScript-friendly types (strings, Uint8Array, JsValue). Error handling uses JsError for browser console visibility. The crate builds to both web and nodejs targets via wasm-pack.

**Tech Stack:** Rust, wasm-bindgen, wasm-pack, console_error_panic_hook, serde-wasm-bindgen, wasm-bindgen-test

---

## Task 1: Create hush-wasm Crate Structure

**Files:**
- Create: `crates/hush-wasm/Cargo.toml`
- Create: `crates/hush-wasm/src/lib.rs` (minimal stub)
- Modify: `Cargo.toml` (workspace members)

**Step 1: Create Cargo.toml for hush-wasm**

```toml
[package]
name = "hush-wasm"
description = "WebAssembly bindings for hush-core cryptographic verification"
version.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true
rust-version.workspace = true

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
hush-core = { path = "../hush-core" }

# WASM bindings
wasm-bindgen = "0.2"
js-sys = "0.3"
web-sys = { version = "0.3", features = ["console"] }

# Serialization
serde = { workspace = true }
serde_json = { workspace = true }
serde-wasm-bindgen = "0.6"

# Encoding
hex = { workspace = true }

# Better panic messages in browser
console_error_panic_hook = "0.1"

# Cryptographic randomness in WASM
getrandom = { version = "0.2", features = ["js"] }

[dev-dependencies]
wasm-bindgen-test = "0.3"

[features]
default = []

[profile.release]
lto = true
opt-level = "z"
```

**Step 2: Create minimal lib.rs stub**

```rust
//! WebAssembly bindings for hush-core cryptographic primitives
//!
//! This crate provides browser-side verification of clawdstrike attestations.

use wasm_bindgen::prelude::*;

/// Initialize the WASM module (call once at startup)
#[wasm_bindgen(start)]
pub fn init() {
    console_error_panic_hook::set_once();
}

/// Get version information about this WASM module
#[wasm_bindgen]
pub fn version() -> String {
    env!("CARGO_PKG_VERSION").to_string()
}
```

**Step 3: Add hush-wasm to workspace members**

In root `Cargo.toml`, add `"crates/hush-wasm"` to the members array.

**Step 4: Verify it compiles**

Run: `cd /Users/connor/Medica/clawdstrike-ws6-wasm && cargo check -p hush-wasm`
Expected: Compiles successfully

**Step 5: Commit**

```bash
git add crates/hush-wasm/Cargo.toml crates/hush-wasm/src/lib.rs Cargo.toml
git commit -m "feat(hush-wasm): scaffold WASM crate structure"
```

---

## Task 2: Implement Hashing Functions

**Files:**
- Modify: `crates/hush-wasm/src/lib.rs`
- Create: `crates/hush-wasm/tests/web.rs`

**Step 1: Write the failing test for hash_sha256**

Create `crates/hush-wasm/tests/web.rs`:

```rust
#![cfg(target_arch = "wasm32")]

use wasm_bindgen_test::*;
use hush_wasm::*;

wasm_bindgen_test_configure!(run_in_browser);

#[wasm_bindgen_test]
fn test_hash_sha256() {
    let hash = hash_sha256(b"hello");
    assert_eq!(
        hash,
        "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"
    );
}

#[wasm_bindgen_test]
fn test_hash_sha256_empty() {
    let hash = hash_sha256(b"");
    assert_eq!(hash.len(), 64); // 32 bytes = 64 hex chars
}
```

**Step 2: Implement hash_sha256**

Add to `lib.rs`:

```rust
use hush_core::sha256;

/// Compute SHA-256 hash of data.
///
/// # Arguments
/// * `data` - The bytes to hash
///
/// # Returns
/// Hex-encoded hash (64 characters, no prefix)
#[wasm_bindgen]
pub fn hash_sha256(data: &[u8]) -> String {
    sha256(data).to_hex()
}

/// Compute SHA-256 hash with 0x prefix.
#[wasm_bindgen]
pub fn hash_sha256_prefixed(data: &[u8]) -> String {
    sha256(data).to_hex_prefixed()
}
```

**Step 3: Write tests for hash_keccak256**

Add to `tests/web.rs`:

```rust
#[wasm_bindgen_test]
fn test_hash_keccak256() {
    let hash = hash_keccak256(b"hello");
    // Keccak-256 of "hello" - returns with 0x prefix
    assert!(hash.starts_with("0x"));
    assert_eq!(hash.len(), 66); // 0x + 64 hex chars
}
```

**Step 4: Implement hash_keccak256**

Add to `lib.rs`:

```rust
use hush_core::keccak256;

/// Compute Keccak-256 hash of data (Ethereum-compatible).
///
/// # Arguments
/// * `data` - The bytes to hash
///
/// # Returns
/// Hex-encoded hash with 0x prefix (66 characters)
#[wasm_bindgen]
pub fn hash_keccak256(data: &[u8]) -> String {
    keccak256(data).to_hex_prefixed()
}
```

**Step 5: Verify compilation**

Run: `cd /Users/connor/Medica/clawdstrike-ws6-wasm && cargo check -p hush-wasm`
Expected: Compiles successfully

**Step 6: Commit**

```bash
git add crates/hush-wasm/src/lib.rs crates/hush-wasm/tests/web.rs
git commit -m "feat(hush-wasm): add SHA-256 and Keccak-256 hash functions"
```

---

## Task 3: Implement Ed25519 Signature Verification

**Files:**
- Modify: `crates/hush-wasm/src/lib.rs`
- Modify: `crates/hush-wasm/tests/web.rs`

**Step 1: Write the failing test**

Add to `tests/web.rs`:

```rust
#[wasm_bindgen_test]
fn test_verify_ed25519_valid() {
    // Test with known good signature (generated from hush-core tests)
    // We'll use a deterministic seed to get predictable keys
    let pubkey_hex = "d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a";
    let message = b"";
    let sig_hex = "e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e065224901555fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b";

    let result = verify_ed25519(pubkey_hex, message, sig_hex);
    assert!(result.is_ok());
    assert!(result.unwrap());
}

#[wasm_bindgen_test]
fn test_verify_ed25519_invalid_signature() {
    let pubkey_hex = "d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a";
    let message = b"wrong message";
    let sig_hex = "e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e065224901555fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b";

    let result = verify_ed25519(pubkey_hex, message, sig_hex);
    assert!(result.is_ok());
    assert!(!result.unwrap()); // Should be false for wrong message
}

#[wasm_bindgen_test]
fn test_verify_ed25519_invalid_pubkey() {
    let result = verify_ed25519("invalid", b"test", "0".repeat(128).as_str());
    assert!(result.is_err());
}
```

**Step 2: Implement verify_ed25519**

Add to `lib.rs`:

```rust
use hush_core::{PublicKey, Signature};

/// Verify an Ed25519 signature over a message.
///
/// # Arguments
/// * `public_key_hex` - Hex-encoded public key (32 bytes, with or without 0x prefix)
/// * `message` - The message bytes that were signed
/// * `signature_hex` - Hex-encoded signature (64 bytes, with or without 0x prefix)
///
/// # Returns
/// `true` if the signature is valid, `false` otherwise
#[wasm_bindgen]
pub fn verify_ed25519(
    public_key_hex: &str,
    message: &[u8],
    signature_hex: &str,
) -> Result<bool, JsError> {
    let pubkey = PublicKey::from_hex(public_key_hex)
        .map_err(|e| JsError::new(&e.to_string()))?;
    let sig = Signature::from_hex(signature_hex)
        .map_err(|e| JsError::new(&e.to_string()))?;

    Ok(pubkey.verify(message, &sig))
}
```

**Step 3: Verify compilation**

Run: `cd /Users/connor/Medica/clawdstrike-ws6-wasm && cargo check -p hush-wasm`
Expected: Compiles successfully

**Step 4: Commit**

```bash
git add crates/hush-wasm/src/lib.rs crates/hush-wasm/tests/web.rs
git commit -m "feat(hush-wasm): add Ed25519 signature verification"
```

---

## Task 4: Implement Receipt Verification

**Files:**
- Modify: `crates/hush-wasm/src/lib.rs`
- Modify: `crates/hush-wasm/tests/web.rs`

**Step 1: Write the failing test**

Add to `tests/web.rs`:

```rust
#[wasm_bindgen_test]
fn test_verify_receipt_valid() {
    // Create a valid signed receipt JSON
    let receipt_json = r#"{
        "receipt": {
            "version": "1.0.0",
            "receipt_id": "test-001",
            "timestamp": "2026-01-01T00:00:00Z",
            "content_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "verdict": {"passed": true}
        },
        "signatures": {
            "signer": "e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e065224901555fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b"
        }
    }"#;

    // This will fail verification because the signature doesn't match
    // but it should parse correctly
    let result = verify_receipt(receipt_json, "d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a", None);
    assert!(result.is_ok());
}

#[wasm_bindgen_test]
fn test_verify_receipt_invalid_json() {
    let result = verify_receipt("not valid json", "abc123", None);
    assert!(result.is_err());
}
```

**Step 2: Implement verify_receipt**

Add to `lib.rs`:

```rust
use hush_core::{SignedReceipt, receipt::PublicKeySet};

/// Verify a signed Receipt.
///
/// # Arguments
/// * `receipt_json` - JSON-serialized SignedReceipt
/// * `signer_pubkey_hex` - Hex-encoded signer public key
/// * `cosigner_pubkey_hex` - Optional hex-encoded co-signer public key
///
/// # Returns
/// JavaScript object with verification result:
/// ```json
/// {
///   "valid": true,
///   "signer_valid": true,
///   "cosigner_valid": null,
///   "errors": []
/// }
/// ```
#[wasm_bindgen]
pub fn verify_receipt(
    receipt_json: &str,
    signer_pubkey_hex: &str,
    cosigner_pubkey_hex: Option<String>,
) -> Result<JsValue, JsError> {
    let signed: SignedReceipt = serde_json::from_str(receipt_json)
        .map_err(|e| JsError::new(&format!("Invalid receipt JSON: {}", e)))?;

    let signer_pk = PublicKey::from_hex(signer_pubkey_hex)
        .map_err(|e| JsError::new(&e.to_string()))?;

    let cosigner_pk = match cosigner_pubkey_hex {
        Some(hex) => Some(PublicKey::from_hex(&hex)
            .map_err(|e| JsError::new(&e.to_string()))?),
        None => None,
    };

    let keys = match cosigner_pk {
        Some(pk) => PublicKeySet::new(signer_pk).with_cosigner(pk),
        None => PublicKeySet::new(signer_pk),
    };

    let result = signed.verify(&keys);

    serde_wasm_bindgen::to_value(&result)
        .map_err(|e| JsError::new(&format!("Serialization failed: {}", e)))
}
```

**Step 3: Add hash_receipt function**

Add to `lib.rs`:

```rust
use hush_core::Receipt;

/// Hash a Receipt to get its canonical hash.
///
/// # Arguments
/// * `receipt_json` - JSON-serialized Receipt (unsigned)
/// * `algorithm` - "sha256" or "keccak256"
///
/// # Returns
/// Hex-encoded hash with 0x prefix
#[wasm_bindgen]
pub fn hash_receipt(
    receipt_json: &str,
    algorithm: &str,
) -> Result<String, JsError> {
    let receipt: Receipt = serde_json::from_str(receipt_json)
        .map_err(|e| JsError::new(&format!("Invalid receipt JSON: {}", e)))?;

    let hash = match algorithm {
        "sha256" => receipt.hash_sha256(),
        "keccak256" => receipt.hash_keccak256(),
        _ => return Err(JsError::new("Invalid algorithm: use 'sha256' or 'keccak256'")),
    }.map_err(|e| JsError::new(&e.to_string()))?;

    Ok(hash.to_hex_prefixed())
}
```

**Step 4: Verify compilation**

Run: `cd /Users/connor/Medica/clawdstrike-ws6-wasm && cargo check -p hush-wasm`
Expected: Compiles successfully

**Step 5: Commit**

```bash
git add crates/hush-wasm/src/lib.rs crates/hush-wasm/tests/web.rs
git commit -m "feat(hush-wasm): add receipt verification and hashing"
```

---

## Task 5: Implement Merkle Tree Functions

**Files:**
- Modify: `crates/hush-wasm/src/lib.rs`
- Modify: `crates/hush-wasm/tests/web.rs`

**Step 1: Write failing tests**

Add to `tests/web.rs`:

```rust
#[wasm_bindgen_test]
fn test_compute_merkle_root() {
    let leaves = r#"["0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef", "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"]"#;
    let root = compute_merkle_root(leaves).unwrap();
    assert!(root.starts_with("0x"));
    assert_eq!(root.len(), 66);
}

#[wasm_bindgen_test]
fn test_verify_merkle_proof() {
    // Build a simple 2-leaf tree and verify proof
    let leaves = r#"["0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef", "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"]"#;
    let root = compute_merkle_root(leaves).unwrap();

    let proof = generate_merkle_proof(leaves, 0).unwrap();
    let leaf_hex = "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";

    let valid = verify_merkle_proof(leaf_hex, &proof, &root).unwrap();
    assert!(valid);
}

#[wasm_bindgen_test]
fn test_merkle_proof_wrong_leaf() {
    let leaves = r#"["0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef", "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"]"#;
    let root = compute_merkle_root(leaves).unwrap();
    let proof = generate_merkle_proof(leaves, 0).unwrap();

    // Wrong leaf
    let wrong_leaf = "0x0000000000000000000000000000000000000000000000000000000000000000";
    let valid = verify_merkle_proof(wrong_leaf, &proof, &root).unwrap();
    assert!(!valid);
}
```

**Step 2: Implement Merkle functions**

Add to `lib.rs`:

```rust
use hush_core::{Hash, MerkleTree, MerkleProof};

/// Verify a Merkle inclusion proof.
///
/// # Arguments
/// * `leaf_hash_hex` - Hex-encoded leaf hash
/// * `proof_json` - JSON-serialized MerkleProof
/// * `root_hex` - Hex-encoded expected root hash
///
/// # Returns
/// `true` if the proof is valid, `false` otherwise
#[wasm_bindgen]
pub fn verify_merkle_proof(
    leaf_hash_hex: &str,
    proof_json: &str,
    root_hex: &str,
) -> Result<bool, JsError> {
    let leaf = Hash::from_hex(leaf_hash_hex)
        .map_err(|e| JsError::new(&e.to_string()))?;
    let root = Hash::from_hex(root_hex)
        .map_err(|e| JsError::new(&e.to_string()))?;
    let proof: MerkleProof = serde_json::from_str(proof_json)
        .map_err(|e| JsError::new(&format!("Invalid proof JSON: {}", e)))?;

    Ok(proof.verify_hash(leaf, &root))
}

/// Compute Merkle root from leaf hashes.
///
/// # Arguments
/// * `leaf_hashes_json` - JSON array of hex-encoded leaf hashes
///
/// # Returns
/// Hex-encoded Merkle root (with 0x prefix)
#[wasm_bindgen]
pub fn compute_merkle_root(leaf_hashes_json: &str) -> Result<String, JsError> {
    let hashes: Vec<String> = serde_json::from_str(leaf_hashes_json)
        .map_err(|e| JsError::new(&format!("Invalid JSON: {}", e)))?;

    let leaf_hashes: Vec<Hash> = hashes
        .iter()
        .map(|h| Hash::from_hex(h))
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| JsError::new(&e.to_string()))?;

    let tree = MerkleTree::from_hashes(leaf_hashes)
        .map_err(|e| JsError::new(&e.to_string()))?;

    Ok(tree.root().to_hex_prefixed())
}

/// Generate a Merkle proof for a specific leaf index.
///
/// # Arguments
/// * `leaf_hashes_json` - JSON array of hex-encoded leaf hashes
/// * `leaf_index` - Index of the leaf to prove (0-based)
///
/// # Returns
/// JSON-serialized MerkleProof
#[wasm_bindgen]
pub fn generate_merkle_proof(
    leaf_hashes_json: &str,
    leaf_index: usize,
) -> Result<String, JsError> {
    let hashes: Vec<String> = serde_json::from_str(leaf_hashes_json)
        .map_err(|e| JsError::new(&format!("Invalid JSON: {}", e)))?;

    let leaf_hashes: Vec<Hash> = hashes
        .iter()
        .map(|h| Hash::from_hex(h))
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| JsError::new(&e.to_string()))?;

    let tree = MerkleTree::from_hashes(leaf_hashes)
        .map_err(|e| JsError::new(&e.to_string()))?;

    let proof = tree.inclusion_proof(leaf_index)
        .map_err(|e| JsError::new(&e.to_string()))?;

    serde_json::to_string(&proof)
        .map_err(|e| JsError::new(&format!("Serialization failed: {}", e)))
}
```

**Step 3: Verify compilation**

Run: `cd /Users/connor/Medica/clawdstrike-ws6-wasm && cargo check -p hush-wasm`
Expected: Compiles successfully

**Step 4: Commit**

```bash
git add crates/hush-wasm/src/lib.rs crates/hush-wasm/tests/web.rs
git commit -m "feat(hush-wasm): add Merkle tree computation and proof verification"
```

---

## Task 6: Add Canonical JSON Export

**Files:**
- Modify: `crates/hush-wasm/src/lib.rs`
- Modify: `crates/hush-wasm/tests/web.rs`

**Step 1: Write failing test**

Add to `tests/web.rs`:

```rust
#[wasm_bindgen_test]
fn test_get_canonical_json() {
    let receipt_json = r#"{
        "version": "1.0.0",
        "timestamp": "2026-01-01T00:00:00Z",
        "content_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
        "verdict": {"passed": true}
    }"#;

    let canonical = get_canonical_json(receipt_json).unwrap();

    // Canonical JSON should have sorted keys and no extra whitespace
    assert!(!canonical.contains('\n'));
    // "content_hash" should come before "timestamp" alphabetically
    let content_pos = canonical.find("content_hash").unwrap();
    let timestamp_pos = canonical.find("timestamp").unwrap();
    assert!(content_pos < timestamp_pos);
}
```

**Step 2: Implement get_canonical_json**

Add to `lib.rs`:

```rust
/// Get the canonical JSON representation of a receipt.
/// This is the exact bytes that are signed.
///
/// # Arguments
/// * `receipt_json` - JSON-serialized Receipt
///
/// # Returns
/// Canonical JSON string (sorted keys, no extra whitespace)
#[wasm_bindgen]
pub fn get_canonical_json(receipt_json: &str) -> Result<String, JsError> {
    let receipt: Receipt = serde_json::from_str(receipt_json)
        .map_err(|e| JsError::new(&format!("Invalid receipt JSON: {}", e)))?;

    receipt.to_canonical_json()
        .map_err(|e| JsError::new(&e.to_string()))
}
```

**Step 3: Verify compilation**

Run: `cd /Users/connor/Medica/clawdstrike-ws6-wasm && cargo check -p hush-wasm`
Expected: Compiles successfully

**Step 4: Commit**

```bash
git add crates/hush-wasm/src/lib.rs crates/hush-wasm/tests/web.rs
git commit -m "feat(hush-wasm): add canonical JSON export for receipts"
```

---

## Task 7: Create Build Script and npm Package

**Files:**
- Create: `crates/hush-wasm/build.sh`
- Create: `crates/hush-wasm/package.json`
- Create: `crates/hush-wasm/README.md`

**Step 1: Create build script**

Create `crates/hush-wasm/build.sh`:

```bash
#!/bin/bash
set -e

echo "Building hush-wasm for web target..."
wasm-pack build --target web --out-dir pkg --out-name hush_wasm

echo "Building hush-wasm for Node.js target..."
wasm-pack build --target nodejs --out-dir pkg-node --out-name hush_wasm

echo "Build complete!"
echo "  Web:    crates/hush-wasm/pkg/"
echo "  Node:   crates/hush-wasm/pkg-node/"
```

**Step 2: Make build script executable**

Run: `chmod +x /Users/connor/Medica/clawdstrike-ws6-wasm/crates/hush-wasm/build.sh`

**Step 3: Create package.json**

Create `crates/hush-wasm/package.json`:

```json
{
  "name": "@clawdstrike/wasm",
  "version": "0.1.0",
  "description": "WebAssembly bindings for clawdstrike cryptographic verification",
  "main": "hush_wasm.js",
  "types": "hush_wasm.d.ts",
  "files": [
    "hush_wasm_bg.wasm",
    "hush_wasm.js",
    "hush_wasm.d.ts",
    "hush_wasm_bg.wasm.d.ts"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/backbay-labs/clawdstrike"
  },
  "keywords": [
    "wasm",
    "cryptography",
    "verification",
    "attestation",
    "ed25519",
    "merkle",
    "clawdstrike"
  ],
  "author": "Clawdstrike Contributors",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/backbay-labs/clawdstrike/issues"
  },
  "homepage": "https://github.com/backbay-labs/clawdstrike#readme"
}
```

**Step 4: Create README.md**

Create `crates/hush-wasm/README.md`:

```markdown
# @clawdstrike/wasm

WebAssembly bindings for clawdstrike cryptographic verification.

## Installation

```bash
npm install @clawdstrike/wasm
```

## Usage (Browser)

```javascript
import init, {
  hash_sha256,
  hash_keccak256,
  verify_ed25519,
  verify_receipt,
  verify_merkle_proof,
  compute_merkle_root,
  generate_merkle_proof,
  get_canonical_json,
  version
} from '@clawdstrike/wasm';

// Initialize WASM module
await init();

// Hash data
const sha256Hash = hash_sha256(new TextEncoder().encode('hello'));
console.log('SHA-256:', sha256Hash);

const keccakHash = hash_keccak256(new TextEncoder().encode('hello'));
console.log('Keccak-256:', keccakHash);

// Verify Ed25519 signature
const valid = verify_ed25519(publicKeyHex, message, signatureHex);
console.log('Signature valid:', valid);

// Verify a signed receipt
const result = verify_receipt(receiptJson, signerPubkeyHex);
console.log('Receipt verification:', result);

// Merkle tree operations
const root = compute_merkle_root(JSON.stringify(leafHashes));
const proof = generate_merkle_proof(JSON.stringify(leafHashes), 0);
const proofValid = verify_merkle_proof(leafHash, proof, root);
```

## Usage (Node.js)

```javascript
const {
  hash_sha256,
  verify_ed25519,
  verify_receipt
} = require('@clawdstrike/wasm');

// Functions work synchronously in Node.js
const hash = hash_sha256(Buffer.from('hello'));
```

## API

### Hashing

- `hash_sha256(data: Uint8Array): string` - SHA-256 hash (hex, no prefix)
- `hash_sha256_prefixed(data: Uint8Array): string` - SHA-256 hash (0x-prefixed hex)
- `hash_keccak256(data: Uint8Array): string` - Keccak-256 hash (0x-prefixed hex)

### Signatures

- `verify_ed25519(publicKeyHex: string, message: Uint8Array, signatureHex: string): boolean`

### Receipts

- `verify_receipt(receiptJson: string, signerPubkeyHex: string, cosignerPubkeyHex?: string): VerificationResult`
- `hash_receipt(receiptJson: string, algorithm: 'sha256' | 'keccak256'): string`
- `get_canonical_json(receiptJson: string): string`

### Merkle Trees

- `compute_merkle_root(leafHashesJson: string): string`
- `generate_merkle_proof(leafHashesJson: string, leafIndex: number): string`
- `verify_merkle_proof(leafHashHex: string, proofJson: string, rootHex: string): boolean`

### Utilities

- `version(): string` - Get WASM module version

## Building from Source

```bash
# Install wasm-pack
cargo install wasm-pack

# Build for web
./build.sh

# Or build manually
wasm-pack build --target web --out-dir pkg
```

## License

MIT
```

**Step 5: Commit**

```bash
git add crates/hush-wasm/build.sh crates/hush-wasm/package.json crates/hush-wasm/README.md
git commit -m "feat(hush-wasm): add build script and npm package configuration"
```

---

## Task 8: Create TypeScript Type Definitions

**Files:**
- Create: `crates/hush-wasm/types/hush_wasm.d.ts`

**Step 1: Create TypeScript definitions**

Create `crates/hush-wasm/types/hush_wasm.d.ts`:

```typescript
/**
 * TypeScript type definitions for @clawdstrike/wasm
 *
 * These augment the auto-generated wasm-bindgen types with
 * more detailed documentation and type information.
 */

/** Verification result from verify_receipt */
export interface VerificationResult {
  /** Overall validity - true only if all signatures are valid */
  valid: boolean;
  /** Primary signer signature valid */
  signer_valid: boolean;
  /** Co-signer signature valid (null if no co-signer) */
  cosigner_valid: boolean | null;
  /** Error messages if verification failed */
  errors: string[];
}

/** Initialize the WASM module (called automatically on import) */
export function init(): void;

/** Get the WASM module version */
export function version(): string;

/**
 * Compute SHA-256 hash of data
 * @param data - Bytes to hash
 * @returns Hex-encoded hash (64 chars, no prefix)
 */
export function hash_sha256(data: Uint8Array): string;

/**
 * Compute SHA-256 hash with 0x prefix
 * @param data - Bytes to hash
 * @returns Hex-encoded hash with 0x prefix
 */
export function hash_sha256_prefixed(data: Uint8Array): string;

/**
 * Compute Keccak-256 hash (Ethereum-compatible)
 * @param data - Bytes to hash
 * @returns Hex-encoded hash with 0x prefix
 */
export function hash_keccak256(data: Uint8Array): string;

/**
 * Verify an Ed25519 signature
 * @param publicKeyHex - Hex-encoded public key (32 bytes)
 * @param message - Message bytes that were signed
 * @param signatureHex - Hex-encoded signature (64 bytes)
 * @returns true if signature is valid
 * @throws Error if keys/signature are malformed
 */
export function verify_ed25519(
  publicKeyHex: string,
  message: Uint8Array,
  signatureHex: string
): boolean;

/**
 * Verify a signed receipt
 * @param receiptJson - JSON-serialized SignedReceipt
 * @param signerPubkeyHex - Hex-encoded signer public key
 * @param cosignerPubkeyHex - Optional hex-encoded co-signer public key
 * @returns Verification result object
 * @throws Error if JSON is malformed or keys are invalid
 */
export function verify_receipt(
  receiptJson: string,
  signerPubkeyHex: string,
  cosignerPubkeyHex?: string
): VerificationResult;

/**
 * Hash a receipt using specified algorithm
 * @param receiptJson - JSON-serialized Receipt
 * @param algorithm - "sha256" or "keccak256"
 * @returns Hex-encoded hash with 0x prefix
 * @throws Error if JSON is malformed or algorithm is invalid
 */
export function hash_receipt(
  receiptJson: string,
  algorithm: 'sha256' | 'keccak256'
): string;

/**
 * Get canonical JSON representation of a receipt
 * @param receiptJson - JSON-serialized Receipt
 * @returns Canonical JSON (sorted keys, no whitespace)
 * @throws Error if JSON is malformed
 */
export function get_canonical_json(receiptJson: string): string;

/**
 * Verify a Merkle inclusion proof
 * @param leafHashHex - Hex-encoded leaf hash
 * @param proofJson - JSON-serialized MerkleProof
 * @param rootHex - Hex-encoded expected root hash
 * @returns true if proof is valid
 * @throws Error if hashes are malformed
 */
export function verify_merkle_proof(
  leafHashHex: string,
  proofJson: string,
  rootHex: string
): boolean;

/**
 * Compute Merkle root from leaf hashes
 * @param leafHashesJson - JSON array of hex-encoded leaf hashes
 * @returns Hex-encoded root with 0x prefix
 * @throws Error if hashes are malformed
 */
export function compute_merkle_root(leafHashesJson: string): string;

/**
 * Generate a Merkle inclusion proof
 * @param leafHashesJson - JSON array of hex-encoded leaf hashes
 * @param leafIndex - 0-based index of leaf to prove
 * @returns JSON-serialized MerkleProof
 * @throws Error if index is out of bounds
 */
export function generate_merkle_proof(
  leafHashesJson: string,
  leafIndex: number
): string;
```

**Step 2: Commit**

```bash
git add crates/hush-wasm/types/hush_wasm.d.ts
git commit -m "feat(hush-wasm): add TypeScript type definitions"
```

---

## Task 9: Verify WASM Build

**Files:**
- None (verification only)

**Step 1: Install wasm-pack if needed**

Run: `which wasm-pack || cargo install wasm-pack`

**Step 2: Build WASM for web target**

Run: `cd /Users/connor/Medica/clawdstrike-ws6-wasm/crates/hush-wasm && wasm-pack build --target web --out-dir pkg`
Expected: Build succeeds, creates pkg/ directory with .wasm and .js files

**Step 3: Check bundle size**

Run: `ls -lh /Users/connor/Medica/clawdstrike-ws6-wasm/crates/hush-wasm/pkg/*.wasm`
Expected: Size < 500KB

**Step 4: Build for Node.js target**

Run: `cd /Users/connor/Medica/clawdstrike-ws6-wasm/crates/hush-wasm && wasm-pack build --target nodejs --out-dir pkg-node`
Expected: Build succeeds

**Step 5: Run WASM tests in headless browser**

Run: `cd /Users/connor/Medica/clawdstrike-ws6-wasm/crates/hush-wasm && wasm-pack test --headless --chrome`
Expected: All tests pass

Note: If Chrome is not available, use `--node` instead:
Run: `cd /Users/connor/Medica/clawdstrike-ws6-wasm/crates/hush-wasm && wasm-pack test --node`

---

## Task 10: Final Integration Test

**Files:**
- Create: `crates/hush-wasm/tests/integration.rs`

**Step 1: Create integration test**

Create `crates/hush-wasm/tests/integration.rs`:

```rust
//! Integration tests for hush-wasm
//! These run as regular Rust tests (not WASM)

use hush_core::{Keypair, Receipt, SignedReceipt, Verdict, Hash};

#[test]
fn test_full_receipt_workflow() {
    // Create a receipt
    let content_hash = hush_core::sha256(b"test content");
    let receipt = Receipt::new(content_hash, Verdict::pass())
        .with_id("integration-test-001");

    // Sign it
    let keypair = Keypair::generate();
    let signed = SignedReceipt::sign(receipt, &keypair).unwrap();

    // Serialize to JSON
    let json = signed.to_json().unwrap();

    // This would be verified in WASM
    let restored = SignedReceipt::from_json(&json).unwrap();
    let keys = hush_core::receipt::PublicKeySet::new(keypair.public_key());
    let result = restored.verify(&keys);

    assert!(result.valid);
    assert!(result.signer_valid);
}

#[test]
fn test_merkle_proof_workflow() {
    use hush_core::{MerkleTree, sha256};

    // Create leaves
    let leaves: Vec<Vec<u8>> = (0..5)
        .map(|i| format!("leaf-{}", i).into_bytes())
        .collect();

    // Build tree
    let tree = MerkleTree::from_leaves(&leaves).unwrap();
    let root = tree.root();

    // Generate proof for leaf 2
    let proof = tree.inclusion_proof(2).unwrap();

    // Verify proof
    assert!(proof.verify(&leaves[2], &root));

    // Serialize proof to JSON
    let proof_json = serde_json::to_string(&proof).unwrap();
    let restored: hush_core::MerkleProof = serde_json::from_str(&proof_json).unwrap();

    assert!(restored.verify(&leaves[2], &root));
}
```

**Step 2: Run integration tests**

Run: `cd /Users/connor/Medica/clawdstrike-ws6-wasm && cargo test -p hush-wasm --test integration`
Expected: All tests pass

**Step 3: Commit**

```bash
git add crates/hush-wasm/tests/integration.rs
git commit -m "test(hush-wasm): add integration tests for full workflows"
```

---

## Summary

After completing all tasks, the hush-wasm crate provides:

1. **Hashing**: `hash_sha256`, `hash_sha256_prefixed`, `hash_keccak256`
2. **Signatures**: `verify_ed25519`
3. **Receipts**: `verify_receipt`, `hash_receipt`, `get_canonical_json`
4. **Merkle Trees**: `compute_merkle_root`, `generate_merkle_proof`, `verify_merkle_proof`
5. **Utilities**: `version`

The crate builds to < 500KB WASM bundle and works in both browser and Node.js environments.
